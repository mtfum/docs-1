"use strict";(self.webpackChunkinterep_docs=self.webpackChunkinterep_docs||[]).push([[317],{3905:function(e,t,r){r.d(t,{Zo:function(){return l},kt:function(){return d}});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var p=n.createContext({}),c=function(e){var t=n.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},l=function(e){var t=c(e.components);return n.createElement(p.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=c(r),d=o,m=u["".concat(p,".").concat(d)]||u[d]||h[d]||i;return r?n.createElement(m,a(a({ref:t},l),{},{components:r})):n.createElement(m,a({ref:t},l))}));function d(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=r.length,a=new Array(i);a[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=r[c];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},1785:function(e,t,r){r.r(t),r.d(t,{assets:function(){return l},contentTitle:function(){return p},default:function(){return d},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return h}});var n=r(3117),o=r(102),i=(r(7294),r(3905)),a=["components"],s={sidebar_position:1,title:"Introduction"},p="Groups",c={unversionedId:"technical-reference/groups/intro",id:"technical-reference/groups/intro",title:"Introduction",description:"Interep allows users to join groups based on reputation gained on social networks or other platforms. Groups are basically sets of user identities organized as Merkle trees. What makes these groups extremely useful is the fact that users can prove that they belong to them without revealing their identity. This is possible thanks to the use of so-called ZK-Snarks and Semaphore.",source:"@site/docs/technical-reference/groups/intro.md",sourceDirName:"technical-reference/groups",slug:"/technical-reference/groups/intro",permalink:"/technical-reference/groups/intro",editUrl:"https://github.com/interep-project/docs/edit/main/docs/technical-reference/groups/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Introduction"},sidebar:"tutorialSidebar",previous:{title:"Twitter",permalink:"/technical-reference/reputation/twitter"},next:{title:"OAuth",permalink:"/technical-reference/groups/oauth"}},l={},h=[{value:"Joining a group",id:"joining-a-group",level:2},{value:"Generating a proof",id:"generating-a-proof",level:2},{value:"Providers",id:"providers",level:2}],u={toc:h};function d(e){var t=e.components,r=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"groups"},"Groups"),(0,i.kt)("p",null,"Interep allows users to join groups based on reputation gained on social networks or other platforms. Groups are basically sets of user identities organized as Merkle trees. What makes these groups extremely useful is the fact that users can prove that they belong to them without revealing their identity. This is possible thanks to the use of so-called ZK-Snarks and Semaphore."),(0,i.kt)("p",null,"This important feature can therefore be divided into two important steps: a first step in which users can join groups, and a second step in which those users can generate their anonymous proof to prove that they belong to a group."),(0,i.kt)("p",null,"So let's see how Interep enables this feature and how these technologies are used."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"In cryptography and computer science, a hash tree or ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Merkle_tree"},"Merkle tree"),' is a tree in which every "leaf" (node) is labelled with the cryptographic hash of a data block, and every node that is not a leaf (called a branch, inner node, or inode) is labelled with the cryptographic hash of the labels of its child nodes.'))),(0,i.kt)("h2",{id:"joining-a-group"},"Joining a group"),(0,i.kt)("p",null,"In the first phase Interep allows users to join groups with the web application or via ",(0,i.kt)("a",{parentName:"p",href:"/api"},"API"),", that can be used by external services. Although there are different types of groups, the way users are added is the same. Each user uses their Ethereum account to generate an identity commitment that uniquely represents the user and the type of group they wish to join."),(0,i.kt)("p",null,"Group types are defined by identity providers, i.e. the services from which the information necessary to certify a certain reputation or certain properties is obtained. Whereas the users Ethereum account is used to sign a message with the identity provider and to generate a Semaphore identity."),(0,i.kt)("p",null,"Interep uses the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/interep-project/interep.js/tree/main/packages/identity"},"@interep/identity")," package to generate identities, while the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/interep-project/reputation-service"},"reputation-service")," takes care of adding the identity commitments in the Merkle tree associated with the group."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Interep does not save any association between Ethereum accounts and Web2 providers."))),(0,i.kt)("h2",{id:"generating-a-proof"},"Generating a proof"),(0,i.kt)("p",null,"In the second phase Interep provides ",(0,i.kt)("a",{parentName:"p",href:"/api#groups"},"APIs")," to allow external services to use groups to authenticate users who belong to a certain group without revealing their identity. The APIs allow, for example, to obtain a list of groups with the size of each one (i.e. number of users of the group), to verify if an identity commitment belongs to a group or to obtain a Merkle proof related to the leaf of a tree (i.e. identity commitment of a group)."),(0,i.kt)("p",null,"Merkle proofs can therefore be used to create zero-knowledge proofs with Semaphore."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"A Merkle proof, or proof of membership, is the tree data needed to verify that a leaf belongs to the tree. Merkle trees allow you to do this type of verification in a very efficient and secure manner. Demonstrating that a leaf node is a part of a given binary Merkle tree, for example, requires computing a number of hashes proportional to the logarithm of the number of leaf nodes in the tree."))),(0,i.kt)("h2",{id:"providers"},"Providers"),(0,i.kt)("p",null,"Group types, as mentioned earlier, are defined by providers. Each provider has its own flow in the system and differs essentially in the ways in which it is verified that a user meets certain properties (e.g. social reputation)."),(0,i.kt)("p",null,"The next paragraphs discuss in more detail the different providers currently supported by Interep."))}d.isMDXComponent=!0}}]);